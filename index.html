<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>你是好人吗？——横版问答通关小游戏</title>
<style>
  :root { --w: 900px; --h: 520px; }
  * { box-sizing: border-box; }
  body {
    margin: 0;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans SC", "PingFang SC", "Hiragino Sans GB", sans-serif;
    background: #0f1020;
    color: #eee;
    display: grid;
    place-items: center;
    min-height: 100vh;
  }
  .shell { width: min(100vw, var(--w)); }
  .hud {
    display:flex; align-items:center; justify-content:space-between; gap:.75rem;
    margin:.5rem auto; font-size:14px; opacity:.9;
  }
  .hud .badge { padding:.25rem .5rem; background:#23243b; border-radius:.5rem; }
  .stage {
    aspect-ratio: 16/9; width:100%;
    background: linear-gradient(#7bd0ff, #c8ecff 45%, #7ccf8a 45%, #5aa262 60%, #6a4d2f 60%);
    border:2px solid #2a2b4b; border-radius:12px; position:relative; overflow:hidden;
  }
  canvas { width:100%; height:100%; display:block; }
  .panel {
    position:absolute; left:0; right:0; bottom:0;
    background: rgba(12,13,28,.86);
    border-top:1px solid rgba(255,255,255,.08);
    padding:.9rem .9rem 1rem; display:grid; gap:.6rem;
  }
  .q { font-weight:700; line-height:1.35; }
  .choices { display:grid; grid-template-columns:1fr 1fr; gap:.6rem; }
  button.choice {
    font:inherit; border:1px solid rgba(255,255,255,.15);
    background:#2a2b4b; color:#fff; padding:.7rem .9rem; border-radius:.6rem;
    cursor:pointer; transition: transform .05s ease, background .2s ease;
    text-align:left; line-height:1.25; min-height:3rem;
    -webkit-tap-highlight-color: rgba(255,255,255,0.05);
  }
  button.choice:active { transform: translateY(0); }
  .toolbar { display:flex; gap:.5rem; justify-content:flex-end; margin-top:.25rem; }
  .btn {
    font:inherit; border:1px solid rgba(255,255,255,.2); background:#1e2038;
    color:#fff; padding:.4rem .65rem; border-radius:.5rem; cursor:pointer;
    -webkit-tap-highlight-color: rgba(255,255,255,0.05);
  }
  .toast {
    position:absolute; top:.5rem; left:50%; transform:translateX(-50%);
    background:rgba(0,0,0,.45); padding:.35rem .6rem; border-radius:.5rem; font-size:12px;
  }
  .legend { font-size:12px; opacity:.8; }
</style>
</head>
<body>
<div class="shell">
  <div class="hud">
    <div class="badge">场景 <span id="sceneIdx">1</span> / <span id="sceneTotal">1</span></div>
    <div class="legend">提示：按 1 / 2 也可选择；空格=提示</div>
    <div class="badge">分支：<span id="pathName">未定</span></div>
  </div>

  <div class="stage">
    <canvas id="game" width="896" height="504" aria-label="横版问答通关"></canvas>
    <div id="toast" class="toast" style="display:none;"></div>
    <div class="panel">
      <div class="q" id="question">你是好人吗？</div>
      <div class="choices">
        <button class="choice" id="c1" type="button">是，我是好人</button>
        <button class="choice" id="c2" type="button">不是，我不是好人</button>
      </div>
      <div class="toolbar">
        <button class="btn" id="btnBack" type="button">上一步</button>
        <button class="btn" id="btnRestart" type="button">重新开始</button>
      </div>
    </div>
  </div>
</div>

<script>
/* ---------- 数据：问题图谱 ---------- */
const NODES = {
  start: { id:'start', text:'你是好人吗？', good:{label:'是，我是好人', next:'g1'}, bad:{label:'不是，我不是好人', next:'b1'} },
  g1: { id:'g1', text:'作为好人，你是否做过让你后悔的坏事？', good:{label:'有，但我努力补救', next:'g2'}, bad:{label:'从不，我洁身自好', next:'g2b'} },
  g2: { id:'g2', text:'你帮过陌生人却不求回报吗？', good:{label:'经常，这让我开心', next:'g3'}, bad:{label:'偶尔，看心情', next:'g3b'} },
  g2b:{ id:'g2b', text:'当朋友犯错，你会如实指出吗？', good:{label:'会，忠言逆耳', next:'g3'}, bad:{label:'看关系深浅', next:'g3b'} },
  g3:{ id:'g3', text:'面对不公，你敢为弱者发声吗？', good:{label:'敢，我会站出来', next:'g4'}, bad:{label:'怕麻烦，少管为妙', next:'g4b'} },
  g3b:{ id:'g3b', text:'你是否愿意为过错道歉并承担后果？', good:{label:'愿意，责任在我', next:'g4'}, bad:{label:'不会，时间会淡化', next:'g4b'} },
  g4:{ id:'g4', text:'恭喜，你在好人之路越走越远！继续前进？', good:{label:'继续，向更远处', next:'gend'}, bad:{label:'先到这吧', next:'gend'} },
  g4b:{ id:'g4b', text:'好人与人的距离，常在一个决定之间。', good:{label:'我想做得更好', next:'gend'}, bad:{label:'保持现状就好', next:'gend'} },
  gend:{ id:'gend', text:'好人结局：路很长，持续选择善。', good:{label:'重新开始', next:'start'}, bad:{label:'换走坏人线', next:'b1'} },

  b1: { id:'b1', text:'作为“坏人”，你做过什么好事吗？', good:{label:'有，偶尔会心软', next:'b2'}, bad:{label:'没有，我行我素', next:'b2b'} },
  b2: { id:'b2', text:'如果有人曾帮助你，你会回报吗？', good:{label:'会，恩情要还', next:'b3'}, bad:{label:'不欠谁的', next:'b3b'} },
  b2b:{ id:'b2b', text:'你是否把“坏”当成保护色？', good:{label:'也许吧，我怕受伤', next:'b3'}, bad:{label:'不，我喜欢掌控', next:'b3b'} },
  b3:{ id:'b3', text:'当你做了坏事，良心会不安吗？', good:{label:'会，我想补偿', next:'b4'}, bad:{label:'不会，适者生存', next:'b4b'} },
  b3b:{ id:'b3b', text:'你是否愿意为了重要的人改变？', good:{label:'愿意，值得', next:'b4'}, bad:{label:'不，谁也别想', next:'b4b'} },
  b4:{ id:'b4', text:'也许你并不坏，只是不被理解。', good:{label:'我想重新开始', next:'bend'}, bad:{label:'让我再想想', next:'bend'} },
  b4b:{ id:'b4b', text:'坏并不难，难的是停下来回头看。', good:{label:'或许该停一停', next:'bend'}, bad:{label:'继续向下走', next:'bend'} },
  bend:{ id:'bend', text:'坏人结局：向下走多了，也别忘了抬头看看。', good:{label:'返回开局', next:'start'}, bad:{label:'试试好人线', next:'g1'} }
};

/* ---------- 画面/角色 ---------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

const TILE = 64;
const SCREEN_W = W, SCREEN_H = H;

let camera = { x:0, y:0 };
let player = { x:48, y: H - 160, r:18, vx:0, vy:0, moving:false };
let path = '未定';

function drawBackground(){
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = '#6bb0e0'; ctx.fillRect(0,0,W,H/2);
  for(let i=0;i<5;i++){
    let cx = (i*220 + (Date.now()/50)%220) % (SCREEN_W*2) - camera.x/4;
    let cy = 80 + (i%2)*30 - camera.y/4;
    ctx.beginPath(); ctx.ellipse(cx, cy, 55, 22, 0, 0, Math.PI*2); ctx.fill();
  }
  ctx.fillStyle = '#5aa262';
  ctx.fillRect(-camera.x, H-100 - camera.y, SCREEN_W*3, H);
  ctx.fillStyle = '#ffffff55'; ctx.font = '16px system-ui';
  ctx.fillText('→ 好人线 向右', 12 - camera.x, H - 112 - camera.y);
  ctx.fillText('↓ 坏人线 向下', 12 - camera.x, H - 92 - camera.y);
}

function drawPlayer(){
  const px = player.x - camera.x;
  const py = player.y - camera.y;
  ctx.lineWidth = 3; ctx.strokeStyle = '#222'; ctx.fillStyle = '#ffd369';
  ctx.beginPath(); ctx.arc(px, py - 22, player.r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
  ctx.strokeStyle = '#111';
  ctx.beginPath(); ctx.moveTo(px, py - 4); ctx.lineTo(px, py + 26); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(px - 18, py + 6); ctx.lineTo(px + 18, py + 6); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(px, py + 26); ctx.lineTo(px - 12, py + 50); ctx.moveTo(px, py + 26); ctx.lineTo(px + 12, py + 50); ctx.stroke();
}

const steps = [];
function spawnStep(x,y){ steps.push({x,y,t:0}); }
function drawSteps(dt){
  for(let i=steps.length-1;i>=0;i--){
    const p = steps[i]; p.t += dt;
    const alpha = Math.max(0,0.6 - p.t*0.6);
    if(alpha <= 0){ steps.splice(i,1); continue; }
    ctx.fillStyle = `rgba(0,0,0,${alpha})`;
    ctx.beginPath(); ctx.arc(p.x - camera.x, p.y - camera.y + 50, 3, 0, Math.PI*2); ctx.fill();
  }
}

/* ---------- 问答逻辑与动画 ---------- */
const qEl = document.getElementById('question');
const c1 = document.getElementById('c1');
const c2 = document.getElementById('c2');
const toast = document.getElementById('toast');
const sceneIdxEl = document.getElementById('sceneIdx');
const sceneTotalEl = document.getElementById('sceneTotal');
const pathNameEl = document.getElementById('pathName');
const btnBack = document.getElementById('btnBack');
const btnRestart = document.getElementById('btnRestart');

let historyStack = [];
let current = NODES.start;
let sceneIndex = 1, sceneTotal = 1;

function setPanel(node){
  qEl.textContent = node.text;
  c1.textContent = node.good.label;
  c2.textContent = node.bad.label;
  sceneIdxEl.textContent = String(sceneIndex);
  sceneTotalEl.textContent = String(sceneTotal);
  pathNameEl.textContent = path;
}

function showToast(msg, ms=900){
  toast.textContent = msg; toast.style.display='block';
  setTimeout(()=> toast.style.display='none', ms);
}

function moveAndLoad(choice){
  if(player.moving) return;
  const dir = (choice === 'good') ? 'right' : 'down';
  if(path === '未定') path = (choice === 'good') ? '好人线' : '坏人线';
  const dx = (dir === 'right') ? TILE * 2 : 0;
  const dy = (dir === 'down') ? TILE * 2 : 0;

  animateMove(dx, dy, () => {
    if(dir==='right' && (player.x - camera.x) > SCREEN_W * 0.7){
      camera.x += SCREEN_W; sceneIndex++; sceneTotal = Math.max(sceneTotal, sceneIndex);
      showToast('进入新画面 →');
    }
    if(dir==='down' && (player.y - camera.y) > SCREEN_H * 0.7){
      camera.y += SCREEN_H; sceneIndex++; sceneTotal = Math.max(sceneTotal, sceneIndex);
      showToast('进入新画面 ↓');
    }
    historyStack.push({ id: current.id, path, px: player.x, py: player.y, cx: camera.x, cy: camera.y, sceneIndex, sceneTotal });
    current = NODES[current[choice].next];
    setPanel(current);
  });
}

function animateMove(dx, dy, onDone){
  player.moving = true;
  const DURATION = 420; const startX = player.x, startY = player.y;
  const start = performance.now();
  function step(t){
    const k = Math.min(1, (t - start) / DURATION);
    const ease = k < .5 ? 2*k*k : -1 + (4 - 2*k)*k;
    player.x = startX + dx * ease; player.y = startY + dy * ease;
    spawnStep(player.x, player.y);
    if(k < 1) requestAnimationFrame(step); else { player.moving = false; onDone && onDone(); }
  }
  requestAnimationFrame(step);
}

function backOneStep(){
  if(!historyStack.length){ showToast('已经在最初'); return; }
  const h = historyStack.pop(); current = NODES[h.id]; path = h.path;
  player.x = h.px; player.y = h.py; camera.x = h.cx; camera.y = h.cy;
  sceneIndex = h.sceneIndex; sceneTotal = h.sceneTotal;
  setPanel(current); showToast('已返回上一步', 700);
}

function restart(){
  historyStack = []; current = NODES.start;
  player = { x:48, y: H - 160, r:18, vx:0, vy:0, moving:false };
  camera = { x:0, y:0 }; path = '未定'; sceneIndex = 1; sceneTotal = 1;
  setPanel(current); showToast('已重开');
}

/* ---------- 事件（触摸+点击） ---------- */
function bindButtonWithTouch(el, fn){
  let touched = false;
  el.addEventListener('touchstart', function(e){
    e.preventDefault(); touched = true; fn();
  }, { passive:false });
  el.addEventListener('click', function(){
    if(touched){ touched = false; return; } fn();
  });
}

bindButtonWithTouch(c1, ()=>moveAndLoad('good'));
bindButtonWithTouch(c2, ()=>moveAndLoad('bad'));
bindButtonWithTouch(btnBack, backOneStep);
bindButtonWithTouch(btnRestart, restart);

window.addEventListener('keydown', (e) => {
  if(player.moving && e.code === 'Space') return;
  if(e.key === '1') moveAndLoad('good');
  else if(e.key === '2') moveAndLoad('bad');
  else if(e.code === 'Space') showToast('选择 1/2 继续前进', 600);
  else if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') backOneStep();
});

/* ---------- 主循环 ---------- */
let last = performance.now();
function loop(now){
  const dt = Math.min(0.05, (now - last) / 1000); last = now;
  drawBackground(); drawSteps(dt); drawPlayer();
  requestAnimationFrame(loop);
}
setPanel(current); requestAnimationFrame(loop);
</script>
</body>
</html>
